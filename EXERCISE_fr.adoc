= API HTTP en utilisant la librairie standard : production et consommation
:tip-caption: üí°
:note-caption: ‚ÑπÔ∏è
:warning-caption: ‚ö†Ô∏è
:icons: font
:hardbreaks-option:

Pr√©fix√© par ‚úîÔ∏è, des "checkpoints" pour vous aider √† v√©rifier que vous avez tout bon.

Cet exercice a pour but de voir l‚Äôutilisation d‚ÄôAPI HTTP JSON, en

* production : le code d√©marre un serveur HTTP qui r√©pond √† des requ√™tes sp√©cifiques
* consommation : le code appelle un serveur HTTP distant

Le th√®me de cet exercice est de construire un programme autonome de jeu de bataille navale.
La bataille aura lieu entre deux programmes ayant la m√™me API (Application Programming Interface).
Vous n‚Äôen construirez qu‚Äôun, mais il pourra se battre contre lui-m√™me.

Il s‚Äôagira d‚Äôune API HTTP et le format d‚Äô√©change des donn√©es sera le JSON.

WARNING: Il est recommand√© d'utiliser la librairie https://github.com/FasterXML/jackson[Jackson] afin de transformer des records en JSON et inversement.

'''

Le lieu de la bataille navale est une mer d√©coup√©e en 10 colonnes et 10 lignes, soit 100 cases.
Les colonnes sont appel√©es de A √† J, alors que les lignes seront nomm√©es de 1 √† 10.
Ainsi, si la mer est un tableau √† deux dimensions, C7 correspondra √† `Cell target = sea[6][2]; // 7th row, 3rd col`;
Cette repr√©sentation avec un tableau est un exemple, vous √™tes libre de repr√©senter le terrain de jeu comme vous l‚Äôentendez.

Les joueurs doivent placer avant la partie 5 bateaux sur la mer :

* 1 porte-avion de 5 cases
* 1 croiseur de 4 cases
* 2 contre-torpilleurs de 3 cases
* 1 torpilleur de 2 cases

== Notation

La notation se d√©coupera en plusieurs parties :

* Le projet compile
* Le projet d√©marre (la m√©thode `fr.lernejo.navy_battle.Launcher#main` doit d√©marrer un serveur HTTP sur le port pass√© comme premier param√®tre)
* Les APIs d√©crites ci-dessous sont
** disponibles
** conformes aux sch√©mas donn√©s
** coh√©rentes
** fonctionnelles
* L‚Äôhistorique **GIT** est lisible et propre
** pas de message de commit sans _**intention**_
** pas de commit successifs avec le m√™me message
** (-0.5 point de p√©nalit√© par commit ne respectant pas ces r√®gles)
** Voir cet article pour plus d‚Äôinformation https://chris.beams.io/posts/git-commit/
* Le **Style** doit permettre de lire le code facilement
** les m√©thodes doivent faire moins de 15 lignes
** les classes moins de 90 lignes
** pas de champs r√©-assignable (tous les champs doivent √™tre marqu√©s final)
** pas de champ ou m√©thode statique (sauf pour la m√©thode `main`)
** (-0.5 point de p√©nalit√© par √©cart)
* L‚Äôint√©gration continue est fonctionnelle
** la couverture du code est > 80%

== Sch√©ma des √©changes
image::img/schema.png[]

== Pr√©requis

* Git
* Java 21
* Maven 3.9.x
* (Optionnel, mais fortement recommand√©) IntelliJ edition _community_ 2024

'''

* Sur la page du template https://github.com/lernejo/maven-starter-template, cliquer sur "Use this template"
* ‚ö†Ô∏è Renseigner comme nom de d√©p√¥t : *navy_battle_project*
* Marquer le futur d√©p√¥t comme *private*
* Une fois le d√©p√¥t cr√©√©, installer l'app https://github.com/apps/korekto[Korekto], ou mettre √† jour sa configuration afin qu'elle ait acc√®s √† ce nouveau d√©p√¥t
* Cloner le d√©p√¥t en utilisant l'*url SSH*
* La branche par d√©faut est la branche *main*, c'est sur celle-ci que nous allons travailler

== Partie 1 - Serveur HTTP
* Cr√©er la classe `fr.lernejo.navy_battle.Launcher` contenant une fonction `main`, ce sera le point d‚Äôentr√©e unique de notre programme
* Cr√©er un serveur HTTP qui √©coutera sur le port indiqu√© comme premier param√®tre du programme
** Pour cela, utiliser `com.sun.net.httpserver.HttpServer#create`
** Sp√©cifier pour ce serveur un `ExecutorService` avec de taille fixe : 1 thread
** Utiliser la m√©thode `createContext` pour associer au chemin `/ping` une impl√©mentation de `HttpHandler` qui renverra une trame HTTP de statut OK (200) et de corps `OK`
* ‚úîÔ∏è une fois le serveur d√©marr√©, il est possible de le tester avec un navigateur internet √† l‚Äôadresse **http://localhost:9876/ping** si le param√®tre du programme est `9876`

[NOTE]
====
La m√©thode `HttpHandler#handle` re√ßoit un param√®tre de type `HttpExchange` dont les diff√©rentes m√©thodes permettent de lire la requ√™te (`headers` et `body`) et d‚Äô√©crire la r√©ponse (`status`, `headers` et `body`).

Par exemple pour renvoyer un code 200 (OK) et le texte `Hello` :

[source,java]
----
String body = "Hello";
exchange.sendResponseHeaders(200, body.length());
try (OutputStream os = exchange.getResponseBody()) { // <1>
    os.write(body.getBytes());
}
----
<1> syntaxe _try-with-resource_ permettant d‚Äôappeler la m√©thode `AutoCloseable#close` √† la fin du bloc sur les objets d√©clar√©s entre parenth√®ses, et ce, m√™me si une exception survient

====

== Partie 2 - Exposer une premi√®re API

Par la suite on consid√®re que si un verbe (GET, POST, etc.) n‚Äôest pas g√©r√©, un appel avec celui-ci renverra une 404 (Not Found).

* Ajouter un contexte pour le chemin `/api/game/start` qui r√©pondra au verbe `POST`
** il est attendu qu‚Äôune telle requ√™te ait un corps respectant le schema suivant :

[source,json]
----
{
    "$schema": "http://json-schema.org/schema#",
    "type": "object",
    "properties": {
        "id": {
            "type": "string"
        },
        "url": {
            "type": "string"
        },
        "message": {
            "type": "string"
        }
    },
    "required": [
        "id",
        "url",
        "message"
    ]
}
----

Par exemple :

[source,json]
----
{
    "id": "0c575465-21f6-43c9-8a2d-bc64c3ae6241",
    "url": "http://localhost:8795",
    "message": "I will crush you!"
}
----

** Le serveur r√©pondra alors avec un statut Accepted (202) et un corps respectant le m√™me schema que le corps de la requ√™te, mais reprenant ses propres informations.

Par exemple :

[source,json]
----
{
    "id": "2aca7611-0ae4-49f3-bf63-75bef4769028",
    "url": "http://localhost:9876",
    "message": "May the best code win"
}
----

** dans le cas o√π le message JSON est malform√©, renvoyer un statut 400 (Bad Request)

== Partie 3 - Consommer cette API

Si un second param√®tre (une URL) est pass√© au programme, apr√®s avoir d√©marr√© son propre serveur HTTP, ce dernier fera une requ√™te `POST` avec son ID, son URL et le message de son choix.

* Pour cela, utiliser `java.net.http.HttpClient#newHttpClient` afin de cr√©er un nouveau client HTTP
* Puis cr√©er un objet `java.net.http.HttpRequest` en utilisant la m√©thode statique `HttpRequest#newBuilder`
* configurer cet objet afin d‚Äô√©mettre une requ√™te correspondante √† l‚ÄôAPI d√©crite ci-dessus (`POST /api/game/start` avec un `body` au bon format), par exemple :

[source,java]
----
HttpRequest requetePost = HttpRequest.newBuilder()
    .uri(URI.create(adversaryUrl + "/api/game/start"))
    .setHeader("Accept", "application/json")
    .setHeader("Content-Type", "application/json")
    .POST(BodyPublishers.ofString("{\"id\":\"1\", \"url\":\"http://localhost:" + myPort + "\", \"message\":\"hello\"}"))
    .build();
----

* ‚úîÔ∏è pour tester le bon fonctionnement, d√©marrer un premier programme sur un port (par ex : `9876`), puis d√©marrer le m√™me programme une deuxi√®me fois avec un port diff√©rent et l‚Äôurl du premier (par ex : `8795 http://localhost:9876`); ainsi le second programme devrait contacter le premier.

== Partie 4 - API de tir

Une seconde API va √™tre n√©cessaire afin que les programmes puissent jouer √† la bataille navale : une API permettant de tirer sur les bateaux de l‚Äôadversaire.

Cette api r√©pondra au verbe `GET` sur le chemin `/api/game/fire` et prendra un param√®tre de requ√™te nomm√© `cell` ayant pour valeur une des cases de la mer (par exemple : **B2** ou **J10**).
La r√©ponse devra √™tre compatible avec le sch√©ma suivant :

[source,json]
----
{
    "$schema": "http://json-schema.org/schema#",
    "type": "object",
    "properties": {
        "consequence": {
            "type": "string",
            "enum": ["miss", "hit", "sunk"]
        },
        "shipLeft": {
            "type": "boolean"
        }
    },
    "required": [
        "consequence",
        "shipLeft"
    ]
}
----

Par exemple :

[source,json]
----
{
    "consequence": "sunk", // <1>
    "shipLeft": true // <2>
}
----
<1> la cellule cibl√©e √©tait la derni√®re partie d‚Äôun bateau touch√©, la r√©ponse indique donc que le bateau est maintenant coul√©
<2> il reste d‚Äôautres bateaux sur la mer, la partie continue

== Partie 5 - Impl√©mentation de la logique

Le but de chaque programme va √™tre de gagner la partie, pour cela le programme va devoir faire (quand c'est √† son tour) un appel √† l'API de tir. Le programme joue en tour par tour jusqu'√† qu'il ait perdu ou gagn√©.

Il faut donc repr√©senter :

* la position et l'√©tat de nos bateaux
* la mer de l'adversaire avec les tirs √©chou√©s et les tirs r√©ussis

Gr√¢ce au retour de l'API, on sait si le tir a :

* manqu√©
* touch√©
* coul√©

La partie s'arr√™te quand l'un des deux programmes n'a plus de bateau.
